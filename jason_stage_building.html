<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>

		<link rel="shortcut icon" href="#">

   
		<style>
					body {
						font-family: Monospace;
						background-color: #000;
						color: #fff;
						margin: 0px;
						overflow: hidden;
					}
					#info {
						position: absolute;
						top: 10px;
						width: 100%;
						text-align: center;
					}
		</style>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.js-master/build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { PointerLockControls } from './three.js-master/examples/jsm/controls/PointerLockControls.js';

//create the scene
var scene = new THREE.Scene( );

//create the webgl renderer
var renderer = new THREE.WebGLRenderer( );

renderer.setSize(window.innerWidth,window.innerHeight);

//add the renderer to the current document
document.body.appendChild(renderer.domElement );


const input = {
  up:false,
  down: false,
  left: false,
  riht: false,
}



//create the perspective camera
//for parameters see https://threejs.org/docs/#api/cameras/PerspectiveCamera
const camera = new THREE.PerspectiveCamera(
  75, // Field of view
  window.innerWidth / window.innerHeight, // aspect ratio
  0.1, // near clipping plane
  1000 // far clipping plane
);
var Pos = new THREE.Vector3(0,0,0);
camera.position.set(Pos.x,Pos.y,Pos.z);
var Dir = new THREE.Vector3(0,0,1);
camera.lookAt(Dir.x,Dir.y,Dir.z);
scene.add(camera); // add the camera to the scene
camera.position.z = -45; 
camera.position.y = 1;

const loader = new THREE.TextureLoader();

const backgroundtexture = loader.load('img/background.jpg');

backgroundtexture.wrapS = THREE.RepeatWrapping;
backgroundtexture.wrapT = THREE.RepeatWrapping;
backgroundtexture.repeat = new THREE.Vector2(60,1)
const backgroundGeometry = new THREE.SphereGeometry( 100, 64,32 );
const backgroundmaterial = new THREE.MeshBasicMaterial( {map: backgroundtexture } );
const backgroundsphere = new THREE.Mesh( backgroundGeometry, backgroundmaterial );
backgroundsphere.material.side = THREE.BackSide;
scene.add( backgroundsphere );

const floorTexture = loader.load( 'img/floor.png' );

floorTexture.wrapS = THREE.RepeatWrapping;
floorTexture.wrapT = THREE.RepeatWrapping;
floorTexture.repeat = new THREE.Vector2(5,5)
const floormaterial = new THREE.MeshPhongMaterial({map: floorTexture});
floormaterial.color = new THREE.Color('#2d2926');

const floorgeometry = new THREE.PlaneGeometry( 30, 100, 10, 10);
const floormesh = new THREE.Mesh( floorgeometry, floormaterial );
floorgeometry.rotateX( - Math.PI / 2 );
floormesh.position.y = -0.5
scene.add( floormesh );

let wallGroup = new THREE.Group(); // create a group to hold the walls
scene.add(wallGroup); // add the group to the scene, then any child added to the group will display to the scene too

const wallTexture = loader.load('img/wall.jpg')
wallTexture.wrapS = THREE.RepeatWrapping;
wallTexture.wrapT = THREE.RepeatWrapping;
wallTexture.repeat = new THREE.Vector2(7,3)
// Front Wall
const wallMaterial = new THREE.MeshLambertMaterial({ map: wallTexture })
const frontWall = new THREE.Mesh(new THREE.BoxGeometry(50, 10, 1), wallMaterial );
 // Lambert material is for non-shiny surfaces 

frontWall.position.z = -50; // push the wall forward in the Z axis
frontWall.position.y = 4.5;

// Left Wall
const leftWall = new THREE.Mesh(new THREE.BoxGeometry(100, 10, 1), wallMaterial );

leftWall.rotation.y = Math.PI / 2; // this is 90 degrees
leftWall.position.x = -7.5; // -20 is for 20 units left
leftWall.position.y = 4.5;

// Right Wall
const rightWall = new THREE.Mesh(new THREE.BoxGeometry(100, 10, 1), wallMaterial );

rightWall.rotation.y = Math.PI / 2; // this is 90 degrees
rightWall.position.x = 7.5; // -20 is for 20 units left
rightWall.position.y = 4.5;

wallGroup.add(frontWall, leftWall, rightWall);

/*var material_box = new THREE.MeshBasicMaterial();
material_box.color=  new THREE.Color(1,0,0);
material_box.wireframe=true;
var geometry_box = new THREE.BoxGeometry(10,0.1,10,32,1,32);

var BoxMesh = new THREE.Mesh(geometry_box,material_box);
BoxMesh.position.y=-1;
scene.add(BoxMesh);*/

const clock = new THREE.Clock();
const movementSpeed = 10;
const rotationSpeed = 2;

update();

function update(){
  const delta = clock.getDelta();
  let facing = new THREE.Vector3();
  camera.getWorldDirection(facing);
  

  if (input.up){
	camera.position.z += facing.z * movementSpeed * delta;
	camera.position.x += facing.x * movementSpeed * delta;
  }
  if (input.down){
	camera.position.z -= facing.z * movementSpeed * delta;
	camera.position.x -= facing.x * movementSpeed * delta;
  }
  if (input.right){
	camera.rotation.y +=rotationSpeed * delta;
  }
  if (input.left){
	camera.rotation.y -=rotationSpeed * delta;
  }

  requestAnimationFrame(update)
  renderer.render(scene, camera);
}



//this function is called when the window is resized
var MyResize = function ( )
{
  //get the new sizes
  var width = window.innerWidth;
  var height = window.innerHeight;
  //then update the renderer
  renderer.setSize(width,height);
  //and update the aspect ratio of the camera
  camera.aspect = width/height;

  //update the projection matrix given the new values
  camera.updateProjectionMatrix();

  //and finally render the scene again
  renderer.render(scene,camera);
};

renderer.render(scene,camera);

//link the resize of the window to the update of the camera
window.addEventListener( 'resize', MyResize);
  document.addEventListener('keydown', (event) =>{
	const key = event.key;
	switch (key){
		case 'w':
		input.up= true;
		break;
		case 's':
		input.down= true;
		break;
		case 'a':
		input.left= true;
		break;
		case 'd':
		input.right= true;
		break;
	}
  })

  document.addEventListener('keyup', (event) =>{
	const key = event.key;
	switch (key){
		case 'w':
		input.up= false;
		break;
		case 's':
		input.down= false;
		break;
		case 'a':
		input.left= false;
		break;
		case 'd':
		input.right= false;
		break;
	}
  })


var ambientlight = new THREE.AmbientLight(new THREE.Color(1,1,1),5);
  scene.add(ambientlight);

				//raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );


/*			function animate() {

				requestAnimationFrame( animate );

				const time = performance.now();

				if ( controls.isLocked === true ) {

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					const intersections = raycaster.intersectObjects( objects, false );

					const onObject = intersections.length > 0;

					const delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

						canJump = true;

					}

				}

				prevTime = time;

				renderer.render( scene, camera );

			}*/

		</script>
	</body>
</html>